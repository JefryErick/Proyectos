<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Análisis de Propagación de Información</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
            :root {
                /* Paleta de colores profesional para estadísticas */
                --primary-blue: #2563eb;
                --primary-blue-dark: #1d4ed8;
                --primary-blue-light: #3b82f6;
                --accent-blue: #0ea5e9;
                --dark-bg: #1e293b;
                --darker-bg: #353942;
                --light-gray: #f8fafc;
                --medium-gray: #64748b;
                --dark-gray: #334155;
                --border-gray: #e2e8f0;
                --text-primary: #0f172a;
                --text-secondary: #475569;
                --text-light: #94a3b8;
                --white: #ffffff;
                --danger: #dc2626;
                --success: #059669;
                --warning: #d97706;
                
                /* Sombras y efectos */
                --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
                --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
                --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                
                /* Transiciones */
                --transition-fast: 0.15s ease-in-out;
                --transition-normal: 0.3s ease-in-out;
                --transition-slow: 0.5s ease-in-out;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
                background: linear-gradient(135deg, var(--dark-bg) 0%, var(--darker-bg) 100%);
                min-height: 100vh;
                color: var(--text-primary);
                line-height: 1.6;
                font-size: 14px;
            }

            .dashboard-container {
                max-width: 1400px;
                margin: 0 auto;
                padding: 24px;
            }

            /* Header con diseño profesional */
            .header {
                background: var(--white);
                border-radius: 12px;
                padding: 32px;
                margin-bottom: 24px;
                box-shadow: var(--shadow-lg);
                border: 1px solid var(--border-gray);
                position: relative;
                overflow: hidden;
            }

            .header::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 4px;
                background: linear-gradient(90deg, var(--primary-blue) 0%, var(--accent-blue) 100%);
            }

            .header h1 {
                font-size: 2.25rem;
                font-weight: 700;
                color: var(--text-primary);
                margin-bottom: 8px;
                letter-spacing: -0.025em;
            }

            .header p {
                font-size: 1.1rem;
                color: var(--text-secondary);
                font-weight: 400;
            }

            /* Panel de controles mejorado */
            .controls-panel {
                background: var(--white);
                border-radius: 12px;
                padding: 24px;
                margin-bottom: 24px;
                box-shadow: var(--shadow-md);
                border: 1px solid var(--border-gray);
            }

            .controls-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                gap: 20px;
                align-items: end;
            }

            .control-group {
                display: flex;
                flex-direction: column;
            }

            .control-group label {
                font-weight: 600;
                color: var(--text-primary);
                margin-bottom: 6px;
                font-size: 13px;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .control-group input, 
            .control-group select {
                padding: 12px 16px;
                border: 2px solid var(--border-gray);
                border-radius: 8px;
                font-size: 14px;
                transition: all var(--transition-fast);
                background: var(--white);
                color: var(--text-primary);
                font-family: inherit;
            }

            .control-group input:focus, 
            .control-group select:focus {
                outline: none;
                border-color: var(--primary-blue);
                box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            }

            .control-group input:hover,
            .control-group select:hover {
                border-color: var(--primary-blue-light);
            }

            /* Botones profesionales */
            .btn {
                background: var(--primary-blue);
                color: var(--white);
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 14px;
                transition: all var(--transition-fast);
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                box-shadow: var(--shadow-sm);
            }

            .btn:hover {
                background: var(--primary-blue-dark);
                transform: translateY(-1px);
                box-shadow: var(--shadow-md);
            }

            .btn:active {
                transform: translateY(0);
            }

            .btn-secondary {
                background: var(--medium-gray);
                color: var(--white);
            }

            .btn-secondary:hover {
                background: var(--dark-gray);
            }

            .btn-danger {
                background: var(--danger);
            }

            .btn-danger:hover {
                background: #b91c1c;
            }

            /* Grid de métricas */
            .metrics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 20px;
                margin-bottom: 24px;
            }

            .metric-card {
                background: var(--white);
                border-radius: 12px;
                padding: 24px;
                box-shadow: var(--shadow-md);
                border: 1px solid var(--border-gray);
                transition: all var(--transition-normal);
                position: relative;
                overflow: hidden;
            }

            .metric-card:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-lg);
            }

            .metric-card::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 3px;
                background: var(--primary-blue);
                transform: scaleX(0);
                transition: transform var(--transition-normal);
            }

            .metric-card:hover::before {
                transform: scaleX(1);
            }

            .metric-header {
                display: flex;
                align-items: center;
                margin-bottom: 16px;
            }

            .metric-icon {
                width: 44px;
                height: 44px;
                border-radius: 10px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-right: 16px;
                font-size: 1.25rem;
                color: var(--white);
                background: var(--primary-blue);
                box-shadow: var(--shadow-sm);
            }

            .metric-icon.success {
                background: var(--success);
            }

            .metric-icon.warning {
                background: var(--warning);
            }

            .metric-icon.danger {
                background: var(--danger);
            }

            .metric-title {
                font-size: 1rem;
                font-weight: 600;
                color: var(--text-primary);
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .metric-value {
                font-size: 2.5rem;
                font-weight: 300;
                color: var(--text-primary);
                margin-bottom: 8px;
                font-family: 'JetBrains Mono', Monaco, 'Courier New', monospace;
            }

            .metric-change {
                font-size: 0.875rem;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .positive { 
                color: var(--success); 
            }
            
            .negative { 
                color: var(--danger); 
            }

            .neutral {
                color: var(--text-secondary);
            }

            /* Grid de gráficos */
            .charts-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
                gap: 24px;
                margin-bottom: 24px;
            }

            .chart-container {
                background: var(--white);
                border-radius: 12px;
                padding: 24px;
                box-shadow: var(--shadow-md);
                border: 1px solid var(--border-gray);
                transition: all var(--transition-normal);
            }

            .chart-container:hover {
                box-shadow: var(--shadow-lg);
            }

            .chart-title {
                font-size: 1.125rem;
                font-weight: 600;
                color: var(--text-primary);
                margin-bottom: 20px;
                text-align: center;
                padding-bottom: 12px;
                border-bottom: 2px solid var(--border-gray);
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .canvas-container {
                position: relative;
                height: 320px;
            }

            /* Panel de validación */
            .validation-panel {
                background: var(--white);
                border-radius: 12px;
                padding: 24px;
                box-shadow: var(--shadow-md);
                border: 1px solid var(--border-gray);
                margin-bottom: 24px;
            }

            .validation-results {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
            }

            .model-results {
                background: var(--light-gray);
                border-radius: 8px;
                padding: 20px;
                border-left: 4px solid var(--primary-blue);
                transition: all var(--transition-fast);
            }

            .model-results:hover {
                background: #f1f5f9;
                border-left-color: var(--primary-blue-dark);
            }

            .model-results.lt-model {
                border-left-color: var(--accent-blue);
            }

            .model-title {
                font-size: 1.125rem;
                font-weight: 600;
                color: var(--text-primary);
                margin-bottom: 16px;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .metric-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
                padding: 10px 0;
                border-bottom: 1px solid var(--border-gray);
                font-family: 'JetBrains Mono', Monaco, 'Courier New', monospace;
            }

            .metric-row:last-child {
                border-bottom: none;
            }

            .metric-row .metric-label {
                font-weight: 500;
                color: var(--text-secondary);
                font-size: 0.875rem;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .metric-row .metric-value {
                font-weight: 600;
                color: var(--text-primary);
                font-size: 1rem;
            }

            /* Visualización de red */
            .network-viz {
                background: var(--white);
                border-radius: 12px;
                padding: 24px;
                box-shadow: var(--shadow-md);
                border: 1px solid var(--border-gray);
            }

            #network-svg {
                width: 100%;
                height: 400px;
                border-radius: 8px;
                border: 1px solid var(--border-gray);
                background: var(--light-gray);
            }

            /* Estados de carga */
            .loading {
                display: none;
                text-align: center;
                padding: 32px;
                color: var(--text-secondary);
            }

            .loading.active {
                display: block;
            }

            .spinner {
                border: 3px solid var(--border-gray);
                border-top: 3px solid var(--primary-blue);
                border-radius: 50%;
                width: 32px;
                height: 32px;
                animation: spin 1s linear infinite;
                margin: 0 auto 16px;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }

            /* Indicadores de estado */
            .status-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                margin-right: 8px;
                position: relative;
            }

            .status-indicator::before {
                content: '';
                position: absolute;
                inset: -2px;
                border-radius: 50%;
                background: inherit;
                opacity: 0.3;
                animation: pulse 2s infinite;
            }

            @keyframes pulse {
                0%, 100% { transform: scale(1); opacity: 0.3; }
                50% { transform: scale(1.2); opacity: 0.1; }
            }

            .status-active { 
                background-color: var(--success); 
            }
            
            .status-inactive { 
                background-color: var(--danger); 
            }
            
            .status-processing { 
                background-color: var(--warning); 
            }

            /* Alertas y notificaciones */
            .alert {
                padding: 16px;
                border-radius: 8px;
                margin-bottom: 16px;
                border: 1px solid transparent;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .alert-info {
                background: #dbeafe;
                border-color: #bfdbfe;
                color: #1e40af;
            }

            .alert-success {
                background: #d1fae5;
                border-color: #a7f3d0;
                color: #065f46;
            }

            .alert-warning {
                background: #fef3c7;
                border-color: #fde68a;
                color: #92400e;
            }

            .alert-danger {
                background: #fee2e2;
                border-color: #fecaca;
                color: #991b1b;
            }

            /* Responsive design */
            @media (max-width: 768px) {
                .dashboard-container {
                    padding: 16px;
                }
                
                .header {
                    padding: 24px;
                }
                
                .header h1 {
                    font-size: 1.875rem;
                }
                
                .controls-grid {
                    grid-template-columns: 1fr;
                }
                
                .metrics-grid {
                    grid-template-columns: 1fr;
                }
                
                .charts-grid {
                    grid-template-columns: 1fr;
                }
                
                .validation-results {
                    grid-template-columns: 1fr;
                }
            }

            @media (max-width: 480px) {
                .metric-value {
                    font-size: 2rem;
                }
                
                .canvas-container {
                    height: 250px;
                }
            }

            /* Scrollbar personalizada */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }

            ::-webkit-scrollbar-track {
                background: var(--light-gray);
            }

            ::-webkit-scrollbar-thumb {
                background: var(--medium-gray);
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: var(--dark-gray);
            }

            /* Utilidades */
            .text-center { text-align: center; }
            .text-left { text-align: left; }
            .text-right { text-align: right; }
            .font-mono { font-family: 'JetBrains Mono', Monaco, 'Courier New', monospace; }
            .font-bold { font-weight: 700; }
            .font-semibold { font-weight: 600; }
            .uppercase { text-transform: uppercase; }
            .lowercase { text-transform: lowercase; }
            .capitalize { text-transform: capitalize; }
            .tracking-wide { letter-spacing: 0.05em; }
            .tracking-wider { letter-spacing: 0.1em; }
            
            .mb-0 { margin-bottom: 0; }
            .mb-2 { margin-bottom: 8px; }
            .mb-4 { margin-bottom: 16px; }
            .mb-6 { margin-bottom: 24px; }
            
            .mt-0 { margin-top: 0; }
            .mt-2 { margin-top: 8px; }
            .mt-4 { margin-top: 16px; }
            .mt-6 { margin-top: 24px; }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Header -->
        <div class="header">
            <h1>🌐 Análisis de Propagación de Información</h1>
            <p>Dashboard Interactivo para Grafos Temporales y Validación Cruzada</p>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="controls-grid">
                <div class="control-group">
                    <label for="dataset-select">Dataset</label>
                    <select id="dataset-select">
                        <option value="twitter">Twitter Cascade</option>
                        <option value="digg">Digg Social News</option>
                        <option value="memetracker">Memetracker</option>
                        <option value="custom">Dataset Personalizado</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="time-window">Ventana Temporal (horas)</label>
                    <input type="number" id="time-window" value="24" min="1" max="168">
                </div>
                
                <div class="control-group">
                    <label for="bootstrap-samples">Muestras Bootstrap</label>
                    <input type="number" id="bootstrap-samples" value="1000" min="100" max="5000">
                </div>
                
                <div class="control-group">
                    <label for="cv-folds">Folds CV Temporal</label>
                    <input type="number" id="cv-folds" value="5" min="3" max="10">
                </div>
                
                <div class="control-group">
                    <button class="btn" onclick="runAnalysis()">
                        <span class="status-indicator status-inactive"></span>
                        Ejecutar Análisis
                    </button>
                </div>
            </div>
        </div>

        <!-- Key Metrics -->
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-header">
                    <div class="metric-icon" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;">📊</div>
                    <div class="metric-title">Cascadas Detectadas</div>
                </div>
                <div class="metric-value" id="total-cascades">0</div>
                <div class="metric-change positive" id="cascades-change">+0% desde última ejecución</div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <div class="metric-icon" style="background: linear-gradient(135deg, #2ed573, #1e90ff); color: white;">🚀</div>
                    <div class="metric-title">Velocidad Promedio</div>
                </div>
                <div class="metric-value" id="avg-velocity">0.00</div>
                <div class="metric-change" id="velocity-change">nodos/segundo</div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <div class="metric-icon" style="background: linear-gradient(135deg, #ffa726, #ff7043); color: white;">🎯</div>
                    <div class="metric-title">Alcance Máximo</div>
                </div>
                <div class="metric-value" id="max-reach">0</div>
                <div class="metric-change" id="reach-change">nodos alcanzados</div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <div class="metric-icon" style="background: linear-gradient(135deg, #a855f7, #ec4899); color: white;">📈</div>
                    <div class="metric-title">Factor Viral</div>
                </div>
                <div class="metric-value" id="viral-factor">0.00</div>
                <div class="metric-change" id="viral-change">índice de viralidad</div>
            </div>
        </div>

        <!-- Validation Results -->
        <div class="validation-panel">
            <h2 class="chart-title">🔬 Resultados de Validación Cruzada Temporal</h2>
            <div class="validation-results">
                <div class="model-results">
                    <div class="model-title">Modelo de Cascada Independiente (IC)</div>
                    <div class="metric-row">
                        <span>MAE (Error Absoluto Medio):</span>
                        <span id="ic-mae">--</span>
                    </div>
                    <div class="metric-row">
                        <span>RMSE (Error Cuadrático Medio):</span>
                        <span id="ic-rmse">--</span>
                    </div>
                    <div class="metric-row">
                        <span>R² (Coeficiente Determinación):</span>
                        <span id="ic-r2">--</span>
                    </div>
                    <div class="metric-row">
                        <span>Score de Robustez:</span>
                        <span id="ic-robustez">--</span>
                    </div>
                </div>

                <div class="model-results">
                    <div class="model-title">Modelo de Umbral Lineal (LT)</div>
                    <div class="metric-row">
                        <span>MAE (Error Absoluto Medio):</span>
                        <span id="lt-mae">--</span>
                    </div>
                    <div class="metric-row">
                        <span>RMSE (Error Cuadrático Medio):</span>
                        <span id="lt-rmse">--</span>
                    </div>
                    <div class="metric-row">
                        <span>R² (Coeficiente Determinación):</span>
                        <span id="lt-r2">--</span>
                    </div>
                    <div class="metric-row">
                        <span>Score de Robustez:</span>
                        <span id="lt-robustez">--</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts Grid -->
        <div class="charts-grid">
            <div class="chart-container">
                <h3 class="chart-title">📈 Bootstrap de Velocidades de Propagación</h3>
                <div class="canvas-container">
                    <canvas id="bootstrap-chart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3 class="chart-title">🎯 Distribución de Alcances</h3>
                <div class="canvas-container">
                    <canvas id="reach-distribution"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3 class="chart-title">⚡ Métricas de Viralidad</h3>
                <div class="canvas-container">
                    <canvas id="virality-metrics"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3 class="chart-title">🔄 Comparación de Modelos (CV)</h3>
                <div class="canvas-container">
                    <canvas id="models-comparison"></canvas>
                </div>
            </div>
        </div>

        <!-- Network Visualization -->
        <div class="network-viz">
            <h3 class="chart-title">🕸️ Visualización de Red de Propagación</h3>
            <svg id="network-svg"></svg>
        </div>

        <!-- Loading Indicator -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Ejecutando análisis de propagación...</p>
        </div>
    </div>

    <script>

        // Estado global de la aplicación
        let analysisData = {
            cascades: [],
            bootstrap_results: null,
            cv_results: null,
            metrics: {}
        };

        const appCharts = {
            bootstrap: null,
            reach: null,
            virality: null,
            models: null
        };

        // Configuración de colores
        const colors = {
            primary: '#667eea',
            secondary: '#764ba2',
            success: '#27ae60',
            warning: '#f39c12',
            danger: '#e74c3c',
            info: '#3498db'
        };

        // Función principal para ejecutar análisis
        async function runAnalysis() {
            const loading = document.getElementById('loading');
            const btn = document.querySelector('.btn');
            const statusIndicator = btn.querySelector('.status-indicator');

            // Mostrar loading
            loading.style.display = 'block';
            statusIndicator.className = 'status-indicator status-processing';
            btn.disabled = true;

            try {
                const timeWindow = parseInt(document.getElementById('time-window').value);
                const bootstrapSamples = parseInt(document.getElementById('bootstrap-samples').value);
                const cvFolds = parseInt(document.getElementById('cv-folds').value);
                const dataset = document.getElementById('dataset-select').value;

                // Inicia el análisis llamando al backend
                const response = await fetch('/api/run-analysis', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        time_window: timeWindow,
                        bootstrap_samples: bootstrapSamples,
                        cv_folds: cvFolds,
                        dataset_type: dataset
                    })
                });

                const result = await response.json();
                if (!result.success) throw new Error(result.message);

                // Esperar hasta que el análisis termine (polling)
                await waitForAnalysisToComplete();

                // Obtener resultados
                const res = await fetch('/api/results');
                const json = await res.json();
                if (!json.success) throw new Error(json.message);

                analysisData = transformBackendData(json.data);
                updateMetrics();
                updateCharts();
                updateValidationResults();
                updateNetworkVisualization();

                statusIndicator.className = 'status-indicator status-active';
            } catch (error) {
                console.error('Error en análisis:', error);
                statusIndicator.className = 'status-indicator status-inactive';
                alert('Error: ' + error.message);
            } finally {
                loading.style.display = 'none';
                btn.disabled = false;
            }
        }


        // Simular análisis (reemplazar con llamadas reales al backend)
        async function simulateAnalysis(timeWindow, bootstrapSamples, cvFolds) {
            // Simular delay de procesamiento
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Generar datos simulados
            analysisData.cascades = generateSimulatedCascades(20);
            analysisData.bootstrap_results = generateBootstrapResults(bootstrapSamples);
            analysisData.cv_results = generateCVResults(cvFolds);
            analysisData.metrics = calculateMetrics();
        }


        async function waitForAnalysisToComplete() {
            let done = false;
            while (!done) {
                const res = await fetch('/api/status');
                const status = await res.json();
                if (status.progress >= 100) {
                    done = true;
                } else {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        function transformBackendData(data) {
            return {
                cascades: data.cascades_data.map(c => ({
                    id: c.id,
                    reach: c.alcance_total,
                    velocity: c.velocidad_propagacion,
                    depth: c.profundidad_maxima,
                    virality: data.viralidad_metrics.factor_viralizacion?.media || 0
                })),
                bootstrap_results: {
                    velocities: data.bootstrap_results.velocidades_bootstrap,
                    reaches: data.bootstrap_results.alcances_bootstrap
                },
                cv_results: {
                    IC: {
                        mae: data.cv_results.IC?.mae || 0,
                        rmse: data.cv_results.IC?.rmse || 0,
                        r2: data.cv_results.IC?.r2 || 0,
                        robustez: data.robustez_scores.IC || 0
                    },
                    LT: {
                        mae: data.cv_results.LT?.mae || 0,
                        rmse: data.cv_results.LT?.rmse || 0,
                        r2: data.cv_results.LT?.r2 || 0,
                        robustez: data.robustez_scores.LT || 0
                    }
                },
                metrics: {
                    total_cascades: data.basic_metrics.total_cascades,
                    avg_velocity: data.basic_metrics.avg_velocity,
                    max_reach: data.basic_metrics.max_reach,
                    avg_virality: data.viralidad_metrics.factor_viralizacion?.media || 0
                }
            };
        }

        // Generar cascadas simuladas
        function generateSimulatedCascades(count) {
            const cascades = [];
            for (let i = 0; i < count; i++) {
                cascades.push({
                    id: i,
                    reach: Math.floor(Math.random() * 1000) + 10,
                    velocity: Math.random() * 0.5,
                    depth: Math.floor(Math.random() * 8) + 1,
                    virality: Math.random() * 50 + 5
                });
            }
            return cascades;
        }

        // Generar resultados de bootstrap
        function generateBootstrapResults(samples) {
            const velocities = [];
            const reaches = [];
            
            for (let i = 0; i < samples; i++) {
                velocities.push(Math.random() * 0.5);
                reaches.push(Math.floor(Math.random() * 1000) + 10);
            }
            
            return {
                velocities: velocities,
                reaches: reaches,
                confidence_intervals: {
                    velocity: {
                        mean: velocities.reduce((a, b) => a + b) / velocities.length,
                        ci_lower: velocities.sort()[Math.floor(samples * 0.025)],
                        ci_upper: velocities.sort()[Math.floor(samples * 0.975)]
                    }
                }
            };
        }

        // Generar resultados de validación cruzada
        function generateCVResults(folds) {
            return {
                IC: {
                    mae: Math.random() * 100 + 20,
                    rmse: Math.random() * 150 + 30,
                    r2: Math.random() * 0.8 + 0.1,
                    robustez: Math.random() * 0.5 + 0.3
                },
                LT: {
                    mae: Math.random() * 120 + 25,
                    rmse: Math.random() * 160 + 35,
                    r2: Math.random() * 0.7 + 0.15,
                    robustez: Math.random() * 0.4 + 0.4
                }
            };
        }

        // Calcular métricas agregadas
        function calculateMetrics() {
            const cascades = analysisData.cascades;
            return {
                total_cascades: cascades.length,
                avg_velocity: cascades.reduce((sum, c) => sum + c.velocity, 0) / cascades.length,
                max_reach: Math.max(...cascades.map(c => c.reach)),
                avg_virality: cascades.reduce((sum, c) => sum + c.virality, 0) / cascades.length
            };
        }

        // Actualizar métricas principales
        function updateMetrics() {
            const metrics = analysisData.metrics;
            
            document.getElementById('total-cascades').textContent = metrics.total_cascades;
            document.getElementById('avg-velocity').textContent = metrics.avg_velocity.toFixed(4);
            document.getElementById('max-reach').textContent = metrics.max_reach;
            document.getElementById('viral-factor').textContent = metrics.avg_virality.toFixed(2);
        }

        // Actualizar resultados de validación
        function updateValidationResults() {
            const cv = analysisData.cv_results;
            
            // Modelo IC
            document.getElementById('ic-mae').textContent = cv.IC.mae.toFixed(2);
            document.getElementById('ic-rmse').textContent = cv.IC.rmse.toFixed(2);
            document.getElementById('ic-r2').textContent = cv.IC.r2.toFixed(3);
            document.getElementById('ic-robustez').textContent = cv.IC.robustez.toFixed(3);
            
            // Modelo LT
            document.getElementById('lt-mae').textContent = cv.LT.mae.toFixed(2);
            document.getElementById('lt-rmse').textContent = cv.LT.rmse.toFixed(2);
            document.getElementById('lt-r2').textContent = cv.LT.r2.toFixed(3);
            document.getElementById('lt-robustez').textContent = cv.LT.robustez.toFixed(3);
        }
//GRAFICOS----------------------------------------------------------------------------------------------
//GRAFICOS----------------------------------------------------------------------------------------------
    class ChartManager {
        constructor() {
            this.charts = {};
            this.colors = {
                primary: '#3498db',
                secondary: '#9b59b6',
                success: '#2ecc71',
                info: '#17a2b8',
                warning: '#f39c12',
                danger: '#e74c3c'
            };
            this.defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                animation: {
                    duration: 750,
                    easing: 'easeInOutQuart'
                }
            };
        }

        // Método principal para actualizar todos los gráficos
        updateAllCharts(data) {
            if (!data || !this.validateData(data)) {
                console.error('Datos inválidos proporcionados para los gráficos');
                return;
            }

            const chartUpdates = [
                { name: 'bootstrap', method: () => this.updateBootstrapChart(data) },
                { name: 'reach', method: () => this.updateReachDistribution(data) },
                { name: 'virality', method: () => this.updateViralityMetrics(data) },
                { name: 'models', method: () => this.updateModelsComparison(data) }
            ];

            chartUpdates.forEach(chart => {
                this.updateChart(chart.name, chart.method);
            });
        }

        // Método genérico para actualizar un gráfico específico
        updateChart(chartName, updateFunction) {
            try {
                // Destruir gráfico anterior si existe
                this.destroyChart(chartName);
                
                // Crear nuevo gráfico
                updateFunction();
                
                console.log(`Gráfico ${chartName} actualizado exitosamente`);
            } catch (error) {
                console.error(`Error al actualizar el gráfico ${chartName}:`, error);
                this.showChartError(chartName, error.message);
            }
        }

        // Destruir un gráfico específico
        destroyChart(chartName) {
            if (this.charts[chartName]) {
                this.charts[chartName].destroy();
                this.charts[chartName] = null;
            }
        }

        // Validar estructura de datos
        validateData(data) {
            const requiredFields = ['bootstrap_results', 'cascades', 'metrics', 'cv_results'];
            return requiredFields.every(field => data && data[field]);
        }

        // Crear histograma con mejores cálculos
        createHistogram(values, bins = 20) {
            if (!values || values.length === 0) return null;

            const min = Math.min(...values);
            const max = Math.max(...values);
            const binWidth = (max - min) / bins;
            const histogram = new Array(bins).fill(0);
            const labels = [];

            // Crear etiquetas más legibles
            for (let i = 0; i < bins; i++) {
                const binStart = min + i * binWidth;
                const binEnd = min + (i + 1) * binWidth;
                labels.push(`${binStart.toFixed(3)}-${binEnd.toFixed(3)}`);
            }

            // Llenar histograma
            values.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binWidth), bins - 1);
                histogram[binIndex]++;
            });

            return { histogram, labels, min, max };
        }

        // Gráfico de bootstrap mejorado
        updateBootstrapChart(data) {
            const ctx = document.getElementById('bootstrap-chart');
            if (!ctx) {
                console.error('Elemento bootstrap-chart no encontrado');
                return;
            }

            const velocities = data.bootstrap_results?.velocities;
            if (!velocities || velocities.length === 0) {
                console.warn('No hay datos de velocidades para el gráfico de bootstrap');
                return;
            }

            const histogramData = this.createHistogram(velocities);
            if (!histogramData) return;

            const config = {
                type: 'bar',
                data: {
                    labels: histogramData.labels,
                    datasets: [{
                        label: 'Frecuencia de Velocidades',
                        data: histogramData.histogram,
                        backgroundColor: this.colors.primary + '80',
                        borderColor: this.colors.primary,
                        borderWidth: 1,
                        borderRadius: 4,
                        borderSkipped: false
                    }]
                },
                options: {
                    ...this.defaultOptions,
                    plugins: {
                        ...this.defaultOptions.plugins,
                        title: {
                            display: true,
                            text: 'Distribución de Velocidades de Propagación (Bootstrap)'
                        },
                        tooltip: {
                            callbacks: {
                                title: (context) => {
                                    const label = context[0].label;
                                    return `Rango: ${label}`;
                                },
                                label: (context) => {
                                    return `Frecuencia: ${context.parsed.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frecuencia'
                            },
                            grid: {
                                color: '#f0f0f0'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Velocidad de Propagación'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            };

            this.charts.bootstrap = new Chart(ctx, config);
        }

        // Distribución de alcances mejorada
        updateReachDistribution(data) {
            const ctx = document.getElementById('reach-distribution');
            if (!ctx) {
                console.error('Elemento reach-distribution no encontrado');
                return;
            }

            const cascades = data.cascades;
            if (!cascades || cascades.length === 0) {
                console.warn('No hay datos de cascadas para el gráfico de alcance');
                return;
            }

            const scatterData = cascades.map(cascade => ({
                x: cascade.velocity || 0,
                y: cascade.reach || 0,
                depth: cascade.depth || 0
            }));

            const config = {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Alcance vs Velocidad',
                        data: scatterData,
                        backgroundColor: this.colors.info + '80',
                        borderColor: this.colors.info,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointBorderWidth: 2,
                        pointBorderColor: '#fff'
                    }]
                },
                options: {
                    ...this.defaultOptions,
                    plugins: {
                        ...this.defaultOptions.plugins,
                        title: {
                            display: true,
                            text: 'Relación entre Alcance y Velocidad de Propagación'
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.parsed;
                                    return [
                                        `Velocidad: ${point.x.toFixed(3)}`,
                                        `Alcance: ${point.y}`,
                                        `Profundidad: ${context.raw.depth || 'N/A'}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Velocidad de Propagación'
                            },
                            grid: {
                                color: '#f0f0f0'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Alcance (número de nodos)'
                            },
                            grid: {
                                color: '#f0f0f0'
                            }
                        }
                    }
                }
            };

            this.charts.reach = new Chart(ctx, config);
        }

        // Métricas de viralidad mejoradas
        updateViralityMetrics(data) {
            const ctx = document.getElementById('virality-metrics');
            if (!ctx) {
                console.error('Elemento virality-metrics no encontrado');
                return;
            }

            const metrics = data.metrics;
            const cascades = data.cascades;

            if (!metrics || !cascades) {
                console.warn('Datos insuficientes para el gráfico de viralidad');
                return;
            }

            // Calcular métricas normalizadas para el radar
            const avgDepth = cascades.reduce((sum, c) => sum + (c.depth || 0), 0) / cascades.length;
            const avgPersistence = cascades.reduce((sum, c) => sum + (c.persistence || Math.random() * 24 + 6), 0) / cascades.length;

            const avgMetrics = {
                'Factor Viral': (metrics.avg_virality || 0) * 100,
                'Velocidad': (metrics.avg_velocity || 0) * 100,
                'Profundidad': avgDepth * 10, // Normalizar para visualización
                'Persistencia': avgPersistence,
                'Alcance Medio': (metrics.avg_reach || 0) / 10 // Normalizar para visualización
            };

            const config = {
                type: 'radar',
                data: {
                    labels: Object.keys(avgMetrics),
                    datasets: [{
                        label: 'Métricas de Viralidad',
                        data: Object.values(avgMetrics),
                        backgroundColor: this.colors.success + '30',
                        borderColor: this.colors.success,
                        borderWidth: 2,
                        pointBackgroundColor: this.colors.success,
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    ...this.defaultOptions,
                    plugins: {
                        ...this.defaultOptions.plugins,
                        title: {
                            display: true,
                            text: 'Perfil de Viralidad del Contenido'
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: '#f0f0f0'
                            },
                            pointLabels: {
                                font: {
                                    size: 12
                                }
                            }
                        }
                    }
                }
            };

            this.charts.virality = new Chart(ctx, config);
        }

        // Comparación de modelos mejorada
        updateModelsComparison(data) {
            const ctx = document.getElementById('models-comparison');
            if (!ctx) {
                console.error('Elemento models-comparison no encontrado');
                return;
            }

            const cv = data.cv_results;
            if (!cv || !cv.IC || !cv.LT) {
                console.warn('Datos de validación cruzada incompletos');
                return;
            }

            const config = {
                type: 'bar',
                data: {
                    labels: ['MAE', 'RMSE', 'R² (%)', 'Robustez (%)'],
                    datasets: [
                        {
                            label: 'Modelo IC (Independent Cascade)',
                            data: [
                                cv.IC.mae || 0,
                                cv.IC.rmse || 0,
                                (cv.IC.r2 || 0) * 100,
                                (cv.IC.robustez || 0) * 100
                            ],
                            backgroundColor: this.colors.primary + '80',
                            borderColor: this.colors.primary,
                            borderWidth: 1,
                            borderRadius: 4,
                            borderSkipped: false
                        },
                        {
                            label: 'Modelo LT (Linear Threshold)',
                            data: [
                                cv.LT.mae || 0,
                                cv.LT.rmse || 0,
                                (cv.LT.r2 || 0) * 100,
                                (cv.LT.robustez || 0) * 100
                            ],
                            backgroundColor: this.colors.secondary + '80',
                            borderColor: this.colors.secondary,
                            borderWidth: 1,
                            borderRadius: 4,
                            borderSkipped: false
                        }
                    ]
                },
                options: {
                    ...this.defaultOptions,
                    plugins: {
                        ...this.defaultOptions.plugins,
                        title: {
                            display: true,
                            text: 'Comparación de Rendimiento de Modelos'
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: (context) => {
                                    const metric = context.label;
                                    if (metric.includes('MAE') || metric.includes('RMSE')) {
                                        return 'Menor es mejor';
                                    } else if (metric.includes('R²') || metric.includes('Robustez')) {
                                        return 'Mayor es mejor';
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Valor de la Métrica'
                            },
                            grid: {
                                color: '#f0f0f0'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Métricas de Evaluación'
                            }
                        }
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    }
                }
            };

            this.charts.models = new Chart(ctx, config);
        }

        // Mostrar error en el gráfico
        showChartError(chartName, errorMessage) {
            const container = document.getElementById(chartName + '-chart') || 
                            document.getElementById(chartName + '-distribution') || 
                            document.getElementById(chartName + '-metrics') || 
                            document.getElementById(chartName + '-comparison');
            
            if (container) {
                container.innerHTML = `
                    <div class="alert alert-danger" role="alert">
                        <h6>Error en el gráfico</h6>
                        <p class="mb-0">${errorMessage}</p>
                    </div>
                `;
            }
        }

        // Destruir todos los gráficos
        destroyAllCharts() {
            Object.keys(this.charts).forEach(chartName => {
                this.destroyChart(chartName);
            });
        }

        // Redimensionar todos los gráficos
        resizeAllCharts() {
            Object.values(this.charts).forEach(chart => {
                if (chart) {
                    chart.resize();
                }
            });
        }
    }

    // Instancia global del gestor de gráficos
    const chartManager = new ChartManager();

    // Función de compatibilidad con el código existente
    function updateCharts() {
        if (typeof analysisData !== 'undefined') {
            chartManager.updateAllCharts(analysisData);
        } else {
            console.error('analysisData no está definido');
        }
    }

    // Event listeners para redimensionamiento
    window.addEventListener('resize', () => {
        chartManager.resizeAllCharts();
    });

    // Limpiar gráficos al salir
    window.addEventListener('beforeunload', () => {
        chartManager.destroyAllCharts();
    });

//FIN GRAFICOS------------------------------------------------------------------------------------------
//FIN GRAFICOS-----------------------------------------------------------------------------------------
        // Visualización de red mejorada
        function updateNetworkVisualization() {
            const svg = d3.select("#network-svg");
            svg.selectAll("*").remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const height = 400;
            
            // Paleta de colores profesional para estadísticas
            const colorPalette = {
                nodes: {
                    primary: '#2563eb',    // Azul principal
                    secondary: '#0ea5e9',  // Azul secundario
                    accent: '#64748b',     // Gris medio
                    success: '#059669',    // Verde para nodos exitosos
                    warning: '#d97706'     // Naranja para nodos de advertencia
                },
                links: {
                    primary: '#94a3b8',    // Gris claro
                    secondary: '#cbd5e1',  // Gris muy claro
                    active: '#3b82f6'      // Azul para enlaces activos
                },
                background: '#f8fafc'      // Fondo claro
            };
            
            // Agregar fondo con gradiente sutil
            const defs = svg.append('defs');
            
            const gradient = defs.append('radialGradient')
                .attr('id', 'networkBackground')
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '70%');
            
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#ffffff')
                .attr('stop-opacity', 0.8);
            
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', colorPalette.background)
                .attr('stop-opacity', 1);
            
            // Aplicar fondo
            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .attr('fill', 'url(#networkBackground)');
            
            // Generar datos de red simulados con mejores propiedades
            const nodes = [];
            const links = [];
            
            // Crear nodos con diferentes tipos y propiedades
            for (let i = 0; i < 30; i++) {
                const nodeType = Math.floor(Math.random() * 5); // 5 tipos diferentes
                const influence = Math.random();
                
                nodes.push({
                    id: i,
                    group: nodeType,
                    size: Math.random() * 15 + 8, // Tamaño más controlado
                    influence: influence,
                    connections: 0,
                    type: ['hub', 'bridge', 'leaf', 'cluster', 'isolated'][nodeType],
                    label: `N${i}`,
                    importance: Math.random() * 100
                });
            }
            
            // Crear enlaces con pesos y tipos
            for (let i = 0; i < 50; i++) {
                const source = Math.floor(Math.random() * 30);
                const target = Math.floor(Math.random() * 30);
                
                if (source !== target) {
                    const weight = Math.random();
                    links.push({
                        source: source,
                        target: target,
                        weight: weight,
                        type: weight > 0.7 ? 'strong' : weight > 0.3 ? 'medium' : 'weak'
                    });
                    
                    // Contar conexiones
                    nodes[source].connections++;
                    nodes[target].connections++;
                }
            }
            
            // Crear filtros para efectos visuales
            const filter = defs.append('filter')
                .attr('id', 'glow')
                .attr('x', '-50%')
                .attr('y', '-50%')
                .attr('width', '200%')
                .attr('height', '200%');
            
            filter.append('feGaussianBlur')
                .attr('stdDeviation', '3')
                .attr('result', 'coloredBlur');
            
            const feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
            
            // Configurar simulación de fuerzas
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .distance(d => 50 + d.weight * 50)
                    .strength(d => d.weight * 0.5)
                )
                .force("charge", d3.forceManyBody()
                    .strength(d => -(d.connections * 50 + 200))
                )
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide()
                    .radius(d => d.size + 5)
                );
            
            // Crear grupo para enlaces
            const linkGroup = svg.append("g")
                .attr("class", "links");
            
            // Crear enlaces con estilos mejorados
            const link = linkGroup.selectAll("line")
                .data(links)
                .join("line")
                .attr("class", d => `link link-${d.type}`)
                .style("stroke", d => {
                    switch(d.type) {
                        case 'strong': return colorPalette.links.active;
                        case 'medium': return colorPalette.links.primary;
                        default: return colorPalette.links.secondary;
                    }
                })
                .style("stroke-opacity", d => {
                    switch(d.type) {
                        case 'strong': return 0.8;
                        case 'medium': return 0.6;
                        default: return 0.3;
                    }
                })
                .style("stroke-width", d => {
                    switch(d.type) {
                        case 'strong': return 3;
                        case 'medium': return 2;
                        default: return 1;
                    }
                })
                .style("stroke-dasharray", d => d.type === 'weak' ? "3,3" : "none");
            
            // Crear grupo para nodos
            const nodeGroup = svg.append("g")
                .attr("class", "nodes");
            
            // Crear nodos con estilos profesionales
            const node = nodeGroup.selectAll("g")
                .data(nodes)
                .join("g")
                .attr("class", "node")
                .style("cursor", "pointer");
            
            // Círculo principal del nodo
            node.append("circle")
                .attr("r", d => d.size)
                .style("fill", d => {
                    const colors = [
                        colorPalette.nodes.primary,
                        colorPalette.nodes.secondary,
                        colorPalette.nodes.accent,
                        colorPalette.nodes.success,
                        colorPalette.nodes.warning
                    ];
                    return colors[d.group];
                })
                .style("stroke", "#ffffff")
                .style("stroke-width", 2)
                .style("filter", d => d.connections > 5 ? "url(#glow)" : "none");
            
            // Círculo interno para nodos importantes
            node.filter(d => d.importance > 70)
                .append("circle")
                .attr("r", d => d.size * 0.5)
                .style("fill", "rgba(255, 255, 255, 0.8)")
                .style("stroke", "none");
            
            // Etiquetas para nodos importantes
            node.filter(d => d.connections > 3)
                .append("text")
                .text(d => d.label)
                .style("font-family", "'Inter', sans-serif")
                .style("font-size", "10px")
                .style("font-weight", "600")
                .style("fill", "#1e293b")
                .style("text-anchor", "middle")
                .style("dominant-baseline", "central")
                .style("pointer-events", "none");
            
            // Efectos de hover
            node.on("mouseenter", function(event, d) {
                d3.select(this).select("circle")
                    .transition()
                    .duration(200)
                    .attr("r", d.size * 1.2)
                    .style("filter", "url(#glow)");
                
                // Resaltar enlaces conectados
                link.style("stroke-opacity", function(l) {
                    return l.source.id === d.id || l.target.id === d.id ? 1 : 0.1;
                });
                
                // Mostrar información del nodo
                showNodeTooltip(event, d);
            })
            .on("mouseleave", function(event, d) {
                d3.select(this).select("circle")
                    .transition()
                    .duration(200)
                    .attr("r", d.size)
                    .style("filter", d.connections > 5 ? "url(#glow)" : "none");
                
                // Restaurar opacidad de enlaces
                link.style("stroke-opacity", l => {
                    switch(l.type) {
                        case 'strong': return 0.8;
                        case 'medium': return 0.6;
                        default: return 0.3;
                    }
                });
                
                hideNodeTooltip();
            });
            
            // Hacer nodos arrastrables
            node.call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));
            
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Actualizar posiciones en cada tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });
            
            // Agregar zoom y pan
            const zoom = d3.zoom()
                .scaleExtent([0.5, 3])
                .on("zoom", function(event) {
                    const { transform } = event;
                    linkGroup.attr("transform", transform);
                    nodeGroup.attr("transform", transform);
                });
            
            svg.call(zoom);
            
            // Funciones auxiliares para tooltip
            function showNodeTooltip(event, d) {
                const tooltip = d3.select("body")
                    .append("div")
                    .attr("class", "network-tooltip")
                    .style("position", "absolute")
                    .style("background", "rgba(0, 0, 0, 0.8)")
                    .style("color", "white")
                    .style("padding", "8px 12px")
                    .style("border-radius", "4px")
                    .style("font-size", "12px")
                    .style("font-family", "'Inter', sans-serif")
                    .style("pointer-events", "none")
                    .style("opacity", 0);
                
                tooltip.html(`
                    <strong>${d.label}</strong><br>
                    Tipo: ${d.type}<br>
                    Conexiones: ${d.connections}<br>
                    Importancia: ${d.importance.toFixed(1)}%
                `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px")
                .transition()
                .duration(200)
                .style("opacity", 1);
            }
            
            function hideNodeTooltip() {
                d3.selectAll(".network-tooltip")
                    .transition()
                    .duration(200)
                    .style("opacity", 0)
                    .remove();
            }
            
            // Agregar leyenda
            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width - 120}, 20)`);
            
            const legendData = [
                { label: "Hub", color: colorPalette.nodes.primary },
                { label: "Bridge", color: colorPalette.nodes.secondary },
                { label: "Leaf", color: colorPalette.nodes.accent },
                { label: "Cluster", color: colorPalette.nodes.success },
                { label: "Isolated", color: colorPalette.nodes.warning }
            ];
            
            const legendItems = legend.selectAll(".legend-item")
                .data(legendData)
                .join("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(0, ${i * 20})`);
            
            legendItems.append("circle")
                .attr("r", 6)
                .attr("fill", d => d.color)
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 1);
            
            legendItems.append("text")
                .attr("x", 15)
                .attr("y", 0)
                .attr("dy", "0.35em")
                .style("font-family", "'Inter', sans-serif")
                .style("font-size", "10px")
                .style("fill", "#1e293b")
                .text(d => d.label);
            
            // Agregar información de estadísticas
            const stats = svg.append("g")
                .attr("class", "network-stats")
                .attr("transform", "translate(20, 20)");
            
            const statsBox = stats.append("rect")
                .attr("width", 140)
                .attr("height", 60)
                .attr("fill", "rgba(255, 255, 255, 0.9)")
                .attr("stroke", colorPalette.links.primary)
                .attr("stroke-width", 1)
                .attr("rx", 4);
            
            stats.append("text")
                .attr("x", 10)
                .attr("y", 20)
                .style("font-family", "'Inter', sans-serif")
                .style("font-size", "11px")
                .style("font-weight", "600")
                .style("fill", "#1e293b")
                .text(`Nodos: ${nodes.length}`);
            
            stats.append("text")
                .attr("x", 10)
                .attr("y", 35)
                .style("font-family", "'Inter', sans-serif")
                .style("font-size", "11px")
                .style("font-weight", "600")
                .style("fill", "#1e293b")
                .text(`Enlaces: ${links.length}`);
            
            stats.append("text")
                .attr("x", 10)
                .attr("y", 50)
                .style("font-family", "'Inter', sans-serif")
                .style("font-size", "11px")
                .style("font-weight", "600")
                .style("fill", "#1e293b")
                .text(`Densidad: ${((links.length * 2) / (nodes.length * (nodes.length - 1)) * 100).toFixed(1)}%`);
        }

        // Limpiar gráficos cuando la página se cierre o actualice
        window.addEventListener('beforeunload', () => {
            Object.keys(appCharts).forEach(chartName => {
                if (appCharts[chartName]) {
                    appCharts[chartName].destroy();
                }
            });
        });

        // Inicializar dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Configurar Chart.js defaults
            Chart.defaults.font.family = "'Inter', 'Segoe UI', sans-serif";
            Chart.defaults.font.size = 12;
            Chart.defaults.color = '#1e293b';
            
            // Inicializar el dashboard
            initializeDashboard();
        });

        function initializeDashboard() {
            // Aquí puedes poner cualquier inicialización adicional
            runAnalysis();
        }
    </script>
</body>
</html>